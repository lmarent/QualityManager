
/*! htb_functions.h

	Library: NetQoS

    Definition of the htb_functions class.

   Copyright (c) 2014, Luis Andres Marentes C.
   and Contributors.
 
   Permission is hereby granted, free of charge, to any person or organization
   obtaining a copy of the software and accompanying documentation covered by
   this license (the "Software") to use, reproduce, display, distribute,
   execute, and transmit the Software, and to prepare derivative works of the
   Software, and to permit third-parties to whom the Software is furnished to
   do so, all subject to the following:
  
   The copyright notices in the Software and this entire statement, including
   the above license grant, this restriction and the following disclaimer,
   must be included in all copies of the Software, in whole or in part, and
   all derivative works of the Software, unless such copies or derivative
   works are solely in the form of machine-executable object code generated by
   a source language processor.
  
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
   SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
   FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.

*/ 

#ifndef _HTB_FUNCTIONS_H
#define _HTB_FUNCTIONS_H

#include <stdio.h>
#include <inttypes.h>
#include <netlink/netlink.h>
#include <netlink/route/link.h>
#include <netlink/route/tc.h>
#include <netlink/route/qdisc.h>
#include <netlink/route/class.h>
#include <netlink/route/classifier.h>
#include <netlink/route/cls/u32.h>
#include <netlink/attr.h>
#include <arpa/inet.h>
#include <netlink/route/qdisc/htb.h>
#include <netlink/route/qdisc/sfq.h>
#include <linux/if_ether.h>
#include <netlink/attr.h>
#include "TcNetqosErrorCode.h"



#ifdef __cplusplus
extern "C" {
#endif

extern uint32_t NET_ROOT_HANDLE_MAJOR;
extern uint32_t NET_ROOT_HANDLE_MINOR;
extern uint32_t NET_DEFAULT_CLASS;
extern uint32_t NET_FILTER_HANDLE_MINOR;
extern uint32_t NET_HASH_FILTER_TABLE;
extern uint32_t NET_UNHASH_FILTER_TABLE;

/**
 * Compute tc handle based on major and minor parts
 * @ingroup tc
 */
#define NET_HANDLE(maj, min)	(TC_H_MAJ((maj) << 16) | TC_H_MIN(min))


	
int qdisc_add_root_HTB(struct nl_sock *sock, struct rtnl_link *rtnlLink);

int qdisc_delete_root_HTB(struct nl_sock *sock, struct rtnl_link *rtnlLink);

int class_add_HTB_root(struct nl_sock *sock, struct rtnl_link *rtnlLink, 
					   uint64_t rate, uint64_t ceil, uint32_t burst, 
					   uint32_t cburst);

int class_add_HTB(struct nl_sock *sock, struct rtnl_link *rtnlLink, 
				  uint32_t childMin, uint64_t rate, uint64_t ceil, 
				  uint32_t burst, uint32_t cburst, uint32_t prio);
				  
int class_delete_HTB(struct nl_sock *sock, struct rtnl_link *rtnlLink, 
			         uint32_t childMin );				  
				  
int qdisc_add_SFQ_leaf(struct nl_sock *sock, struct rtnl_link *rtnlLink, 
					   uint32_t childMin, int quantum, int limit, 
					   int perturb);

int qdisc_delete_SFQ_leaf(struct nl_sock *sock, 
						  struct rtnl_link *rtnlLink, 
						  uint32_t childMin );

int get_u32(__u32 *val, const char *arg, int base);
						  
/** 
 * Function that creates a unit32_t value from a handler represented as
 *  a string
 */ 
int get_u32_handle(__u32 *handle, const char *str);						  


uint32_t get_u32_parse_handle(const char *cHandle);
						  
/**
 * This function adds a new filter and attach it to a hash table 
 * and set a next hash table link with hash mask
 *
 */
int u32_add_filter_on_ht_with_hashmask(struct nl_sock *sock, struct rtnl_link *rtnlLink, 
		uint32_t prio, uint32_t parentMaj, uint32_t parentMin,
		uint32_t keyval, uint32_t keymask, int keyoff, int keyoffmask, 
		uint32_t htid, uint32_t htlink, uint32_t hmask, uint32_t hoffset );


/**
 * This function adds a new filter and attach it to a hash table 
 * and set a the bucket in 0.
 *
 */
int u32_add_filter_on_ht_without_hashmask(struct nl_sock *sock, struct rtnl_link *rtnlLink, 
		uint32_t prio, uint32_t parentMaj, uint32_t parentMin,
		uint32_t keyval, uint32_t keymask, int keyoff, int keyoffmask, 
		uint32_t htid, uint32_t htlink );						  
						  
/** 
 * Add a new hash table for classifiers
 */
int u32_add_ht(struct nl_sock *sock, struct rtnl_link *rtnlLink, 
			   uint32_t prio, uint32_t parentMaj, uint32_t parentMin, 
			   uint32_t htid, uint32_t divisor);
						  
/** 
 * Delete a hash table created to maintain classifiers
 */
int u32_delete_ht(struct nl_sock *sock, struct rtnl_link *rtnlLink, 
				  uint32_t prio, uint32_t parentMaj, uint32_t parentMin, 
				  uint32_t htid, uint32_t divisor);

/**
 * Function that adds the main hast table. 
 *    We create different filter lists depending on the ip address' last byte.
 * 
 * Create u32 first hash filter table 
 *    Upper limit number of hash tables: 4096 0xFFF
 *    Upper limit in buckets by hash table: 256
 * 
 */
int create_hash_configuration(struct nl_sock *sock, struct rtnl_link *rtnlLink,
							  uint32_t priority, uint32_t parentMaj, uint32_t parentMin);

/**
 * Function that adds the main hast table. 
 *    We create different filter lists depending on the ip address' last byte.
 * 
 * Create u32 first hash filter table 
 *    Upper limit number of hash tables: 4096 0xFFF
 *    Upper limit in buckets by hash table: 256
 * 
 */
int delete_hash_configuration(struct nl_sock *sock, struct rtnl_link *rtnlLink,
							  uint32_t priority, uint32_t parentMaj, uint32_t parentMin);

/**
 * This function allocate and prepare the link for creating a u32 classifier,
 * it should be called before any key is introduced.
 */
int create_u32_classifier(struct nl_sock *sock, 
						  struct rtnl_link *rtnlLink, 
						  struct rtnl_cls **cls_out,
						  uint32_t prio, 
						  uint32_t parentMaj, 
						  uint32_t parentMin,
						  int classfierMaj, 
						  int classfierMin,
						  int htid,
						  int hashkey);

/**
 * This function allocate and prepare the link for creating a u32 classifier,
 * it should be called before any key is introduced.
 */
int delete_u32_classifier(struct nl_sock *sock, 
						  struct rtnl_link *rtnlLink, 
						  struct rtnl_cls **cls_out,
						  uint32_t prio, 
						  uint32_t parentMaj, 
						  uint32_t parentMin,
						  int classfierMaj, 
						  int classfierMin,
						  int htid,
						  int hashkey);

int u32_add_key_filter(struct rtnl_cls *cls, const unsigned char *keyval_str, 
				   const unsigned char *keymask_str, unsigned short len,
				   int keyoff, int keyoffmask );

int save_add_u32_filter(struct nl_sock *sock,
					struct rtnl_cls *cls);

int save_delete_u32_filter(struct nl_sock *sock,
					struct rtnl_cls *cls);
     

#ifdef __cplusplus
}
#endif
					   
#endif // _HTB_FUNCTIONS_H
