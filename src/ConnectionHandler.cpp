//
// ConnectionHandler.cpp
//
// $Id: //ecodtn/0.1/include/ConnectionHandler.cpp#1 $
//
// Library: Ecodtn
// Package: ConnectionHandler
// Module:  NetworkQuality
//
// Definition of the ConnectionHandler class.
//
// Copyright (c) 2014, Luis Andres Marentes C.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include <Poco/Net/SocketReactor.h>
#include <Poco/Net/SocketAcceptor.h>
#include <Poco/Net/SocketNotification.h>
#include <Poco/Net/StreamSocket.h>
#include <Poco/Net/ServerSocket.h>
#include <Poco/NObserver.h>
#include <Poco/Exception.h>
#include <Poco/Thread.h>
#include <Poco/FIFOBuffer.h>
#include <Poco/Delegate.h>
#include <Poco/Util/ServerApplication.h>
#include <Poco/Util/Option.h>
#include <Poco/Util/OptionSet.h>
#include <Poco/Util/HelpFormatter.h>
#include <iostream>
#include "ConnectionHandler.h"
#include "RouteManager.h"

namespace ecodtn
{

namespace net
{


ConnectionHandler::ConnectionHandler(Poco::Net::StreamSocket& socket, Poco::Net::SocketReactor& reactor):
_socket(socket),
_reactor(reactor),
_fifoIn(BUFFER_SIZE, true),
_fifoOut(BUFFER_SIZE, true)
{
	Poco::Util::Application& app = Poco::Util::Application::instance();
	
	app.logger().information("Connection from " + socket.peerAddress().toString());

	_reactor.addEventHandler(_socket, 
		Poco::NObserver<ConnectionHandler,Poco::Net::ReadableNotification>(*this, &ConnectionHandler::onSocketReadable)
		);
				
	_reactor.addEventHandler(_socket, 
				Poco::NObserver<ConnectionHandler, Poco::Net::ShutdownNotification>(*this, &ConnectionHandler::onSocketShutdown)
				);

	_fifoOut.readable += Poco::delegate(this, &ConnectionHandler::onFIFOOutReadable);
	_fifoIn.writable += Poco::delegate(this, &ConnectionHandler::onFIFOInWritable);
}

ConnectionHandler::~ConnectionHandler()
{
	Poco::Util::Application& app = Poco::Util::Application::instance();
	try
	{
		app.logger().information("Disconnecting " + _socket.peerAddress().toString());
	}
	catch (...)
	{
	}
	_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler, 
				Poco::Net::ReadableNotification>(*this, &ConnectionHandler::onSocketReadable));
	_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler, 
				Poco::Net::WritableNotification>(*this, &ConnectionHandler::onSocketWritable));
	_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler, 
				Poco::Net::ShutdownNotification>(*this, &ConnectionHandler::onSocketShutdown));

	_fifoOut.readable -= Poco::delegate(this, &ConnectionHandler::onFIFOOutReadable);
	_fifoIn.writable -= Poco::delegate(this, &ConnectionHandler::onFIFOInWritable);
}

void ConnectionHandler::onFIFOOutReadable(bool& b)
{
	if (b)
		_reactor.addEventHandler(_socket, Poco::NObserver<ConnectionHandler, 
				Poco::Net::WritableNotification>(*this, &ConnectionHandler::onSocketWritable));
	else
		_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler, 
				Poco::Net::WritableNotification>(*this, &ConnectionHandler::onSocketWritable));
}

void ConnectionHandler::onFIFOInWritable(bool& b)
{
	if (b)
		_reactor.addEventHandler(_socket, Poco::NObserver<ConnectionHandler, 
				Poco::Net::ReadableNotification>(*this, &ConnectionHandler::onSocketReadable));
	else
		_reactor.removeEventHandler(_socket, Poco::NObserver<ConnectionHandler, 
				Poco::Net::ReadableNotification>(*this, &ConnectionHandler::onSocketReadable));
}

void ConnectionHandler::onSocketReadable(const Poco::AutoPtr<Poco::Net::ReadableNotification>& pNf)
{
	// some socket implementations (windows) report available
	// bytes on client disconnect, so we double-check here
	if (_socket.available())
	{
		int len = _socket.receiveBytes(_fifoIn.next(), _fifoIn.available() );
		_fifoIn.advance(len);
		
		/*
		// Testing the route option.
		
		// Here we have to capture the input and based on that execute the correct function
		// for now we will check for words: route and quality
		
		char* option_char[BUFFER_SIZE];
		_fifoIn.read(option_char, len); 
		std::string option(option_char);
		std::string response = "";
		if (option == "route"){
			std::cout << "option 1";
			response = "route";
		}else if (option == "quality"){
			std::cout << "option 2";
			response = "quality";
		}else{
			response = "error";
		}	*/
		len = _fifoOut.write(_fifoIn.buffer(), _fifoIn.used());
		//_fifoOut.write(response);
		_fifoIn.drain(len);
	}
}

void ConnectionHandler::onSocketWritable(const Poco::AutoPtr<Poco::Net::WritableNotification>& pNf)
{
	
	int len = _socket.sendBytes((_fifoOut.buffer()).begin(), _fifoOut.used());
	_fifoOut.drain(len);
}

void ConnectionHandler::onSocketShutdown(const Poco::AutoPtr<Poco::Net::ShutdownNotification>& pNf)
{
	delete this;
}

}   /// End net namespace

}  /// End ecodtn namespace

