//
// TrafficControlManager.cpp
//
// $Id: //ecodtn/0.1/include/TrafficControlManager.cpp#1 $
//
// Library: Ecodtn
// Package: TrafficControl
// Module:  NetworkQuality
//
// Definition of the TrafficControlManager class.
//
// Copyright (c) 2014, Luis Andres Marentes C.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#include <Poco/Net/IPAddress.h>
#include <Poco/Net/NetworkInterface.h>
#include <Poco/Mutex.h>
#include <iostream>

#include "TrafficControlManager.h"
#include "TrafficControlException.h"

namespace ecodtn
{

namespace net
{

SubNetworkInterface::SubNetworkInterface(Poco::Net::NetworkInterface &netIint, uint32_t parentMaj, 
					   uint32_t parentMin, uint32_t Maj, uint32_t Min)
{
	
	net_interface = netIint;
	parentMajHandler = parentMaj;  
	parentMinHandler = parentMin;
	MajHandler = Maj;
	MinHandler= Min;
	
}

SubNetworkInterface::~SubNetworkInterface()
{
}

uint32_t SubNetworkInterface::getParentMajorHandler()
{
	return parentMajHandler;
}

uint32_t SubNetworkInterface::getParentMinorHandler()
{
	return parentMinHandler;
}

uint32_t SubNetworkInterface::getMajorHandler()
{
	return MajHandler;
}

uint32_t SubNetworkInterface::getMinorHandler()
{
	return MinHandler;
}


TrafficControlManager::TrafficControlManager(std::string intfc_name):
_sk(NULL),
_link_cache(NULL),
_rtnlLink(NULL)
{
	int err;

	// Allocates memory for the socket.
	_sk = nl_socket_alloc();
	if (!_sk){
		throw TrafficControlException("Socket allocation error");
	}
	std::cout << "Could alloc the socket" << std::endl;
	// Connects the socket
	if ((err = nl_connect(_sk, NETLINK_ROUTE)) < 0) {
		throw TrafficControlException("Socket connect error", err);
	}
	
	std::cout << "Could connect the socket" << std::endl;
	
	// Creates the cache to comunicate thorough the socket.
	if ((err = rtnl_link_alloc_cache(_sk, AF_UNSPEC, &_link_cache))< 0){ 
	    throw TrafficControlException("Unable to allocate cache", err); 
	}
	std::cout << "Could create the allocation cache" << std::endl;
	nl_cache_mngt_provide(_link_cache);
	
	// Creates the link to the interface
	int link_int = rtnl_link_name2i(_link_cache, intfc_name.c_str());
	
    _rtnlLink = rtnl_link_get(_link_cache, link_int);
    if (_rtnlLink == NULL){     
        std::cout << "error" << std::endl;
        throw TrafficControlException("Interface could not find", err);
    }
	std::cout << "Could create the interface link" << std::endl;
}

TrafficControlManager::~TrafficControlManager()
{
	rtnl_link_put(_rtnlLink);
	nl_cache_free(_link_cache);
	nl_socket_free(_sk);
}

void TrafficControlManager::addSubNetworkInterface(Poco::Net::NetworkInterface intf, 
								uint32_t parentMaj, uint32_t parentMin,  
								uint32_t childMaj, uint32_t childMin)
{
	if (intf.supportsIPv4())
	{
		std::string subnet = (intf.subnetMask()).toString();
		SubNetworkInterface node(intf, parentMaj, 
					   parentMin, childMaj, childMin);
		
		_subInterfaces.insert(interfNode(subnet,node));
	}else{ 
		// TODO: Ipv6.
		std::cout << "pending code";
	}
}

void TrafficControlManager::deleteSubNetworkInterface(Poco::Net::NetworkInterface intf)
{
	if (intf.supportsIPv4())
	{
		std::string subnet = (intf.subnetMask()).toString();
		std::map<std::string, SubNetworkInterface>::iterator it;
		it = _subInterfaces.find(subnet);
		_subInterfaces.erase(it);
	}
}
	
void TrafficControlManager::addQdiscRootHTB()
{
	int val_result = 0;
	val_result = qdisc_add_root_HTB(_sk, _rtnlLink);
	check_error(val_result);
}

void TrafficControlManager::deleteQdiscRootHTB()
{
	int val_result = 0;
	val_result = qdisc_delete_root_HTB(_sk, _rtnlLink);
	check_error(val_result);	
}

void TrafficControlManager::addClassRootHTB( uint64_t rate, uint64_t ceil, 
											 uint32_t burst, uint32_t cburst)
{
	int val_result = 0;
    val_result = class_add_HTB_root(_sk, _rtnlLink, rate, ceil, burst, cburst);

    std::cout << "result from class_add_HTB_root";
    std::cout << val_result;
    std::cout << val_result << std::endl;
    
	check_error(val_result);
}


void TrafficControlManager::addClassHTB(Poco::Net::IPAddress ipaddr, 
				  Poco::Net::IPAddress submask, uint64_t rate, uint64_t ceil, 
				  uint32_t burst, uint32_t cburst, uint32_t prio, int quantum, 
				  int limit, int perturb)
{
    // Define local variables
    int val_result = 0;
	int keyoff = 12; // This means that the filter is based in source Ip Address.
	int keyoffmask = 0;
    
    // Finds the subnetwork that the IP Address belongs to
	std::map<std::string, SubNetworkInterface>::iterator it;
	switch (ipaddr.family()){
	  case (Poco::Net::IPAddress::IPv4):
	  	 it = _subInterfaces.find(submask.toString());
	  	break;
	  
	  case (Poco::Net::IPAddress::IPv6):
		// TODO: How to manage the subnet identifier in Ipv6.
	  	break;
	  
	  default:
		throw TrafficControlException("Invalid address"); 
		break;
	}	

	
	// Gets the parentMajor and parentMinor 
	uint32_t parentMaj = (it->second).getMajorHandler();
	uint32_t parentMin = (it->second).getMinorHandler();
	
	// Asks to the subnetwork the new handler 
	uint16_t handler = (it->second).getNextValue();
	
	// Calls the function to add the new class, Qdics and filter
	// Adds the class
	val_result = class_add_HTB(_sk, _rtnlLink, parentMaj, parentMin, 
							   parentMin, handler, rate,  ceil, burst, 
							   cburst, prio);
							   					   
	if ( val_result == ECODTN_NET_TC_SUCCESS ){ 
		
		// Adds the Qdisc
		val_result = qdisc_add_SFQ_leaf(_sk, _rtnlLink, 
						   handler, 0, quantum, limit, perturb);
						   
		if (val_result == ECODTN_NET_TC_SUCCESS){
			// Adds the filter
			std::string ipAddrStr = ipaddr.toString();
			std::string submaskStr = submask.toString();
			val_result = u32_add_filter(_sk, _rtnlLink, prio, ipAddrStr.c_str(), 
										submaskStr.c_str(), keyoff, keyoffmask, 
										handler, 0, handler, 0);
		    
		    if (val_result != ECODTN_NET_TC_SUCCESS){
			
				// Delete the class 
				class_delete_HTB(_sk, _rtnlLink, parentMaj, parentMin, 
								parentMin, handler );
								  
				// Delete the Qdisc
				qdisc_delete_SFQ_leaf(_sk, _rtnlLink, handler, 0 );
				
				// Release the number
				(it->second).releaseValue(handler);
			}
			
		} else{ // error during the Qdisc adding process.
		
			// Delete the class that we create
			class_delete_HTB(_sk, _rtnlLink, parentMaj, parentMin, 
						 parentMin, handler );
							 
			// Release the number
			(it->second).releaseValue(handler);
		
	    }
	} else{  // error during the Class adding process.

		// Release the number
		(it->second).releaseValue(handler);
	}	
	
	check_error(val_result);
}


void TrafficControlManager::deleteClassHTB(Poco::Net::IPAddress ipaddr, 
				  uint64_t rate, Poco::Net::IPAddress submask)
{
    int val_result = 0;
    // find the class associated to the Ip address.
	
	// delete the u32 filter
	
	// delete the Qdisc
	
	// delete the class
	
	// release the number
	check_error(val_result);
}


void TrafficControlManager::check_error(int err_result)
{
	if (err_result < 0){
		switch (err_result){
		case ECODTN_NET_TC_QDISC_ALLOC_ERROR: 
			throw TrafficControlException("Unable to allocate memory for the qdisc struct", err_result);
			break;
		case ECODTN_NET_TC_QDISC_SETUP_ERROR: 
			throw TrafficControlException("Unable to assign the set to the qdisc", err_result);
			break;
		case ECODTN_NET_TC_QDISC_ESTABLISH_ERROR: 
			throw TrafficControlException("Unable to add qdisc", err_result);
			break;
		case ECODTN_NET_TC_CLASS_ALLOC_ERROR: 
			throw TrafficControlException("Can not allocate class object", err_result);
			break;
		case ECODTN_NET_TC_CLASS_SETUP_ERROR: 
			throw TrafficControlException("Can not set HTB to class", err_result);
			break;
		case ECODTN_NET_TC_CLASS_ESTABLISH_ERROR: 
			throw TrafficControlException("Can not allocate HTB Qdisc", err_result);
			break;
		case ECODTN_NET_TC_CLASSIFIER_ALLOC_ERROR: 
			throw TrafficControlException("Can not allocate classifier", err_result);
			break;
		case ECODTN_NET_TC_CLASSIFIER_SETUP_ERROR: 
			throw TrafficControlException("Can not set parameter to classifier", err_result);
			break;
		case ECODTN_NET_TC_CLASSIFIER_ESTABLISH_ERROR: 
			throw TrafficControlException("Can not add classifier", err_result);
			break;
		case ECODTN_NET_TC_LINK_ERROR: 
			throw TrafficControlException("The interface does not exist", err_result);
			break;
		}
	}
}


} /// End net namespace

}  /// End ecodtn namespace
